import groovy.io.FileType

def backendGroup = 'backend'

ext {
    nugetConfigPath = new File(projectDir, 'NuGet.Config')
    nugetConfigPathTestData = new File(projectDir, 'testData/NuGet.Config')
    riderSdkVersionPropsPath = new File(resharperPluginPath, 'RiderSdkPackageVersion.props')

    if (!ext.has('BuildConfiguration'))
        BuildConfiguration = rider_backend_build_configuration
}

task prepareBuildProps {
    group = backendGroup

    // https://www.nuget.org/packages/JetBrains.Rider.SDK/
    // (resolved from /build/riderRD-*/lib/DotNetSdkForRdPlugins/JetBrains.Rider.SDK.*.nupkg)
    doLast {
        def configText = """<Project>
  <PropertyGroup>
    <RiderSDKVersion>[${riderSdkPackageVersion()}]</RiderSDKVersion>
  </PropertyGroup>
</Project>
"""
        writeTextIfChanged(riderSdkVersionPropsPath, configText)
    }
}

task prepareNuGetConfig {
    group = backendGroup

    doLast {
        def nugetPath = getNugetPackagesPath()
        def configText = """<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="resharper-sdk" value="${nugetPath}" />
  </packageSources>
</configuration>
"""
        writeTextIfChanged(nugetConfigPath, configText)
        writeTextIfChanged(nugetConfigPathTestData, configText)
    }
}

task restoreReSharperPluginPackages() {
    group = backendGroup
    description = 'Restores packages for backend plugin'
    dependsOn prepareBuildProps, prepareNuGetConfig

    doLast {
        exec {
            executable = 'dotnet'
            args = ['restore', "${resharperPluginPath.canonicalPath}/ReSharper.Azure.sln" ]
        }
    }
}

/*
 Task to up clean Info, Warning, Error generated files used in ReSharper inspections
 */
task cleanGeneratedErrors {
    group = backendGroup
    description = 'Clean up generated inspection infos, warnings, and warnings'

    def srcDir = "${resharperPluginPath.absolutePath}/src"
    String[] generatedFilesMatches = [
            "Azure.Daemon/Errors/*.Generated.cs"
    ]

    doLast {
        cleanFilesByMask(srcDir, generatedFilesMatches)
    }
}

task cleanBackendProjects {
    group = backendGroup
    description = 'Clean backend projects'
    dependsOn prepareBuildProps, prepareNuGetConfig, cleanGeneratedErrors

    doLast {
        exec {
            executable = 'dotnet'
            args = ['clean', "${resharperPluginPath.canonicalPath}/ReSharper.Azure.sln"]
        }
    }
}

task cleanBin {
    group = backendGroup
    description = 'Clean compiled folders'

    def srcDir = "${resharperPluginPath.absolutePath}/src"
    def cleanupDirNames = [ 'bin', 'obj' ]

    doLast {
        def dirsToDelete = new ArrayList<File>()
        new File(srcDir).eachFileRecurse(FileType.DIRECTORIES) { dirToCheck ->
            if (cleanupDirNames.any { dirToCheck.name == it }) { dirsToDelete << dirToCheck }
        }
        dirsToDelete.forEach { toDelete -> toDelete.deleteDir() }
    }
}

/*
 The task is used to clean up generated backend files including compiled directories and files.
 We need to call this task before building a backend projects
 */
task cleanBackend {
    group = backendGroup
    description = 'Clean all data from backend project'
    dependsOn cleanBackendProjects, cleanBin
}

task buildReSharperPlugin {
    group = backendGroup
    description = 'Builds the full ReSharper backend plugin solution'
    dependsOn restoreReSharperPluginPackages, ':rider:protocol:generateModel'

    def libFiles = [
            "**/bin/$BuildConfiguration/net472/JetBrains.ReSharper.Azure*.dll",
            "**/bin/$BuildConfiguration/net472/JetBrains.ReSharper.Azure*.pdb",
            "Azure.Daemon/bin/$BuildConfiguration/net472/NCrontab.Signed.dll",
    ]

    def srcPath = "${resharperPluginPath.absolutePath}/src"

    doLast {
        def executableName = 'dotnet'
        def arguments = [ 'build', "${resharperPluginPath.canonicalPath}/ReSharper.Azure.sln", "-c", BuildConfiguration ]

        println("Building ReSharper.Azure solution [$BuildConfiguration]...")
        exec {
            executable = executableName
            args = arguments
        }

        println("Validating output contains all expected DLL files...")
        def finder = new FileNameFinder()
        libFiles.forEach { filePattern ->
            def matches = finder.getFileNames(srcPath, filePattern)
            if (matches.isEmpty())
                throw new IllegalStateException("Expected plugin backend file is missing: $filePattern")
        }
    }

    // Set list of expected compiled DLL files to task output files
    outputs.files({
        fileTree(file(srcPath)).matching {
            libFiles.forEach { match -> include match }
        }.collect()
    })
}

project.tasks.clean.dependsOn(project.tasks.cleanBackend)

private File getNugetPackagesPath() {
    def sdkPath = project.parent.setupDependencies.idea.get().classes
    println("SDK path: $sdkPath")

    def riderSdk = new File(sdkPath, 'lib/DotNetSdkForRdPlugins')
    println("NuGet packages path: $riderSdk")

    if (!riderSdk.exists())
        throw new IllegalStateException("${riderSdk} does not exist.")

    if (!riderSdk.isDirectory())
        throw new IllegalStateException("${riderSdk} not a directory.")

    return riderSdk
}

private String riderSdkPackageVersion() {
    def riderSdkPath = getNugetPackagesPath()
    println("Rider SDK path: $riderSdkPath")

    def sdkPackageName = "JetBrains.Rider.SDK"

    def regex = "${sdkPackageName}\\.([\\d\\.]+.*)\\.nupkg"
    def matchingPackage = riderSdkPath.list().find { it =~ regex }
    def groups = matchingPackage =~ regex

    if (groups.groupCount() == 0 || groups[0].size < 2)
        throw new IllegalStateException("Could not match ${sdkPackageName} package version.")

    def packageVersion = groups[0][1]
    println("$sdkPackageName version is $packageVersion")

    return packageVersion
}

private static void writeTextIfChanged(File file, String content) {
    def bytes = content.bytes

    if (!file.isFile() || byteArrayToHexString(file.readBytes()) != byteArrayToHexString(bytes)) {
        println("Writing ${file.canonicalPath}")
        file.withOutputStream { it.write(bytes) }
    }
}

private static String byteArrayToHexString(byte[] byteArray) {
    return byteArray.encodeHex().toString()
}

private static void cleanFilesByMask(String baseDir, String[] masks) {
    def finder = new FileNameFinder()
    masks.each { fileMask ->
        def matches = finder.getFileNames(baseDir, fileMask)
        matches.forEach { match ->
            def toDelete = new File(match)
            if (toDelete.isFile())
                toDelete.delete()
        }
    }
}
